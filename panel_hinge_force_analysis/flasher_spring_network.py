"""
Code written by Trevor K. Carter, started on August 20th, 2024
Derived originally from code generated by ChatGPT


"""
from json import load

from skspatial import objects as skobj
import skspatial.transformation as sktrf
from panel_sectioning import generate_orthonormal_basis

import networkx as nx
import numpy as np
from scipy.optimize import minimize

# Optional: Visualize the relative forces in each spring (e.g., using a bar graph)
import matplotlib.pyplot as plt

def main():
	labeled_flasher = r'C:\Users\thetk\Documents\BYU\Work\pythonProject\panel_array_super-processer\v1\references\warped flasher\mesh_cut_labeled_panelsREAL.json'
	names, centers = get_2d_flasher_centers(labeled_flasher, skip_name='ref')
	# A dictionary containing only panel names and their centers in 2d
	node_data = dict(zip(names, centers))
	#node_data = {0: (0, 0), 1: (1, 0), 2: (0, 1), 3: (1, 1), 4: (0.5, 0.5)}  # Example node positions (x, y)
	
	# Define the node_data (panels)
	edge_list = [('center', 'a1'), ('a1', 'a2'), ('a2', 'a3'), ('a2', 'a5'), ('a3', 'a4'), ('a5', 'a4'), ('a1', 'e5'), ('a3', 'e5'),
				 ('center', 'b1'), ('b1', 'b2'), ('b2', 'b3'), ('b2', 'b5'), ('b3', 'b4'), ('b5', 'b4'), ('b1', 'a5'), ('b3', 'a5'),
				 ('center', 'c1'), ('c1', 'c2'), ('c2', 'c3'), ('c2', 'c5'), ('c3', 'c4'), ('c5', 'c4'), ('c1', 'b5'), ('c3', 'b5'),
				 ('center', 'd1'), ('d1', 'd2'), ('d2', 'd3'), ('d2', 'd5'), ('d3', 'd4'), ('d5', 'd4'), ('d1', 'c5'), ('d3', 'c5'),
				 ('center', 'e1'), ('e1', 'e2'), ('e2', 'e3'), ('e2', 'e5'), ('e3', 'e4'), ('e5', 'e4'), ('e1', 'd5'), ('e3', 'd5')
				 ]
	
	springs = get_springs(node_data, edge_list)
	print(springs)
	force_magnitude = 0.35
	force_node_names = ['a4', 'b4', 'c4', 'd4', 'e4']
	force_nodes = {force_node: node_data[force_node] for force_node in force_node_names}
	force_source = node_data['center']
	external_forces = make_radial_forces(force_magnitude, force_nodes, force_source)
	
	solve_springs(node_data, springs, external_forces)
	
	
def get_springs(node_dict, edge_pairs):
	# Define the springs (edges) and their properties
	k_rigid = 1e6  # Extremely high spring constant to make springs very rigid
	springs = []
	for node_a, node_b in edge_pairs:
		length = np.linalg.norm(node_dict[node_b] - node_dict[node_a])
		springs.append((node_a, node_b, {'k': k_rigid, 'rest_length': length}))
	
	return springs
	

# This takes a .json of labeled panels, extracts their centers, projects them onto their overall
# plane of best fit, and returns normalized 2d coordinates of all panel centers with their original labels
def get_2d_flasher_centers(filepath, skip_name=None):
	with open(filepath, 'r') as json_file:
		flasher_dict = load(json_file)
	panel_names_list = []
	panel_centers_list = []
	for name, data in flasher_dict.items():
		if skip_name is not None:
			if name == skip_name:
				continue
		panel_names_list.append(name)
		panel_centers_list.append(data['center'])

	panel_names = np.array(panel_names_list)
	panel_centers = np.array(panel_centers_list)
	
	best_plane = skobj.Plane.best_fit(panel_centers)
	
	b1, b2 = generate_orthonormal_basis(best_plane)
	
	panel_centers_trf = sktrf.transform_coordinates(panel_centers, (0, 0, 0), (b1, b2, best_plane.normal.unit()))
	panel_centers_2d = panel_centers_trf[:, 0:2]
	
	return panel_names, panel_centers_2d


def make_radial_forces(magnitude, nodes_with_force, source_pos):
	# Define external forces (outward forces) on the outermost nodes
	external_force_list = {}
	for node_name, node_pos in nodes_with_force.items():
		source_to_node = node_pos - source_pos
		node_force_vector = magnitude * source_to_node / np.linalg.norm(source_to_node)
		print("\nFORCE VECTORS:")
		print(node_force_vector)
		external_force_list[node_name] = node_force_vector
	
	return external_force_list
	
	
def solve_springs(nodes, springs, external_forces):
	
	node_names = list(nodes.keys())
	
	# Function to compute the potential energy and include external forces
	def total_potential_energy(positions):
		energy = 0.0
		positions = positions.reshape(-1, 2)
		#print(positions)
		
		# Add spring potential energy
		for (n, p, node_data) in G.edges(data=True):
			#print(n, p, node_data)
			spring_k = node_data['k']
			rest_length = node_data['rest_length']
			pos_n = positions[node_names.index(n)]
			pos_p = positions[node_names.index(p)]
			#pos_n = nodes[n]
			#pos_p = nodes[p]
			displacement = np.linalg.norm(pos_p - pos_n) - rest_length
			energy += 0.5 * spring_k * displacement ** 2
		
		# Add external force contribution (potential energy)
		for force_node, force_vector in external_forces.items():
			print(force_node)
			print(force_vector)
			print(node_names)
			pos_node = positions[node_names.index(force_node)]
			print(pos_node)
			#pos_node = nodes[force_node]
			#print(pos_node)
			energy -= np.dot(force_vector, pos_node)
		
		return energy
	
	# Initialize a NetworkX graph
	G = nx.Graph()
	
	for node, pos in nodes.items():
		G.add_node(node, pos=np.array(pos))
	
	# Add edges (springs) to the graph
	G.add_edges_from(springs)
	
	# Initial positions flattened into a single array
	initial_positions = np.array([pos for node, pos in nodes.items()]).flatten()
	
	# Minimize the potential energy to find the equilibrium state
	result = minimize(total_potential_energy, initial_positions, method='L-BFGS-B')
	print(result)
	
	# Final node positions (reshaped back to 2D)
	equilibrium_positions = result.x.reshape(-1, 2)
	
	# Update graph with the new positions
	for i, node in enumerate(G.nodes()):
		G.nodes[node]['pos'] = equilibrium_positions[np.argwhere(node_names == i)]
	
	# Calculate the forces in each spring
	spring_forces = {}
	for (j, k, data) in G.edges(data=True):
		pos_j = equilibrium_positions[np.argwhere(node_names == j)]
		pos_k = equilibrium_positions[np.argwhere(node_names == k)]
		force_magnitude = data['k'] * (np.linalg.norm(pos_k - pos_j) - data['rest_length'])
		spring_forces[(j, k)] = force_magnitude
	
	# Output the relative forces in the springs
	print("Relative forces in each spring:\n", spring_forces)
	
	spring_labels = [f"{l}-{m}" for (l, m) in spring_forces.keys()]
	forces = list(spring_forces.values())
	
	plt.bar(spring_labels, forces)
	plt.xlabel("Spring (Node Pairs)")
	plt.ylabel("Force Magnitude")
	plt.title("Relative Forces in Springs")
	plt.xticks(rotation=45)
	plt.show()


if __name__ == '__main__':
	main()
